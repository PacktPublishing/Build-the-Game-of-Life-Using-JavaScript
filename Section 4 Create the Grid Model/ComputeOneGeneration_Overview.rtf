{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fnil\fcharset0 HelveticaNeue-Bold;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red46\green45\blue42;\red255\green255\blue255;\red162\green70\blue22;
}
{\*\expandedcolortbl;;\cssrgb\c23529\c23137\c21569;\cssrgb\c100000\c100000\c100000;\cssrgb\c70196\c35294\c10588;
}
{\info
{\author Elisabeth Robson}}\margl1440\margr1440\vieww19520\viewh25200\viewkind0
\deftab720
\pard\pardeftab720\sl920\partightenfactor0

\f0\fs72 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Compute one generation: Overview\
\pard\pardeftab720\sa400\partightenfactor0

\fs36 \cf2 Our goal for next step is simple: to compute one iteration of the Game of Life. After we have that working we'll turn our attention to updating the display, and then to successively computing new generations.\cb1 \
\cb3 For now we're going implement three new functions:\cb1 \
\pard\pardeftab720\sa400\partightenfactor0

\f1\b \cf2 \cb3 computeNextGen
\f0\b0 : This function drives the computation by taking one cell in the grid and passing it to\'a0
\f2 \cf4 \strokec4 applyRules
\f0 \cf2 \strokec2 .\cb1 \

\f1\b \cb3 applyRules
\f0\b0 : This function knows how to apply the rules of the game to a single cell.\cb1 \

\f1\b \cb3 countNeighbors
\f0\b0 : This is a helper function that counts the number of live neighbor cells a cell has.\cb1 \
\pard\pardeftab720\sa400\partightenfactor0
\cf2 \cb3 By breaking up the code to play one round of the game into manageable pieces, we can take it one step at a time, and each piece doesn't get too complex or too long. So follow along with the video as we get these three functions implemented.\cb1 \
}