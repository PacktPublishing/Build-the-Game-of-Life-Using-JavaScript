{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fnil\fcharset0 HelveticaNeue-Italic;\f2\fswiss\fcharset0 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red46\green45\blue42;\red255\green255\blue255;}
{\*\expandedcolortbl;;\cssrgb\c23529\c23137\c21569;\cssrgb\c100000\c100000\c100000;}
{\info
{\author Elisabeth Robson}}\margl1440\margr1440\vieww19520\viewh25200\viewkind0
\deftab720
\pard\pardeftab720\sl920\partightenfactor0

\f0\fs72 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Design the model\
\pard\pardeftab720\sa400\partightenfactor0

\fs36 \cf2 We have a view---that is, a visual interface for our game---and we have a way to add live cells to the grid and some buttons to control the game, so now we need a way to store the state of the game. The state is the information about which cells are alive and which cells are dead in the grid. We need this state to play the game. Right now we have the information about which cells are alive and which are dead in the HTML and CSS---that is, in the view---but this is just our visual interface. Where we really need it is in a\'a0
\f1\i model
\f0\i0 .\cb1 \
\cb3 Remember the exercise you did earlier with the graph paper? You took one piece of graph paper and filled out some of the cells to make them alive. You can think of this as the\'a0
\f1\i state
\f0\i0 \'a0of the grid. Then you applied the rules of the game to this piece of graph paper, and stored the\'a0
\f1\i next state
\f0\i0 \'a0on a new piece of graph paper.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f2\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {{\NeXTGraphic Pasted Graphic.jpg \width25600 \height14400 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}
\f0\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \
\pard\pardeftab720\sa400\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\sa400\partightenfactor0
\cf2 \cb3 We're going to do exactly the same thing with our code. Only instead of using graph paper to store the state, we're going to use two arrays. We'll use one array for the state of the grid as it is now (and as you see it in the view), and we'll use a second array to store the next state of the grid as we apply the rules of the game.\cb1 \
\cb3 These two arrays, and the functions we use to apply the rules of the game to the state stored in these arrays and to generate the next state, are called the\'a0
\f1\i model
\f0\i0 .\cb1 \
}