{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 HelveticaNeue-Italic;
}
{\colortbl;\red255\green255\blue255;\red46\green45\blue42;\red255\green255\blue255;\red162\green70\blue22;
}
{\*\expandedcolortbl;;\cssrgb\c23529\c23137\c21569;\cssrgb\c100000\c100000\c100000;\cssrgb\c70196\c35294\c10588;
}
{\info
{\author Elisabeth Robson}}\margl1440\margr1440\vieww19520\viewh25200\viewkind0
\deftab720
\pard\pardeftab720\sl920\partightenfactor0

\f0\fs72 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 The game plan for the view\
\pard\pardeftab720\sa400\partightenfactor0

\fs36 \cf2 We've just implemented the code to compute the next generation of cells, and we're storing that state in the\'a0
\f1 \cf4 \strokec4 nextGrid
\f0 \cf2 \strokec2 \'a0array. But we don't see that next generation in the view, because all we're doing so far is updating the model\'97the arrays where we're storing the state of the game.\cb1 \
\cb3 There are two things we need to do to update the view. First, we need to copy the state that's in\'a0
\f1 \cf4 \strokec4 nextGrid
\f0 \cf2 \strokec2 \'a0to\'a0
\f1 \cf4 \strokec4 grid
\f0 \cf2 \strokec2 . We do that so that\'a0
\f1 \cf4 \strokec4 grid
\f0 \cf2 \strokec2 \'a0contains the\'a0
\f2\i current state
\f0\i0 \'a0of the game. Using our graph paper metaphor, it's like you're taking the 2nd sheet of graph paper---the one you just used to create the next generation of cells---and you're putting it on top of the first piece of graph paper which you don't need anymore. And, at the same time, you'll grab a fresh piece of graph paper to compute the next generation. So, we'll write a function\'a0
\f1 \cf4 \strokec4 copyAndResetGrid
\f0 \cf2 \strokec2 \'a0to copy the state from\'a0
\f1 \cf4 \strokec4 nextGrid
\f0 \cf2 \strokec2 \'a0to\'a0
\f1 \cf4 \strokec4 grid
\f0 \cf2 \strokec2 , and, at the same time, clear out the\'a0
\f1 \cf4 \strokec4 nextGrid
\f0 \cf2 \strokec2 \'a0array, setting every item to 0, so we're starting fresh.\cb1 \
\cb3 Once we've got the new generation we just computed stored in\'a0
\f1 \cf4 \strokec4 grid
\f0 \cf2 \strokec2 , we'll use it to update the view. We'll do that in a new function,\'a0
\f1 \cf4 \strokec4 updateView
\f0 \cf2 \strokec2 , by iterating through the\'a0
\f1 \cf4 \strokec4 grid
\f0 \cf2 \strokec2 \'a0array, looking at each item in the array, and setting the class of the corresponding cell in the table to either "dead" or "live" depending on if the array is storing a 0 or 1 at a given location.\cb1 \
}